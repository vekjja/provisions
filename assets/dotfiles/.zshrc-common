
#### PATH ####
export PATH="$PATH:/bin:/sbin"
export PATH="$PATH:/usr/bin:/usr/sbin"
export PATH="$PATH:/usr/local/bin:/usr/local/sbin"
export PATH="$PATH:$HOME/.local/bin"

# Terminal Colors
export PURP='\033[0;35m'
export BLU='\033[0;34m'
export YEL='\033[0;33m'
export RED='\033[0;31m'
export GRN='\033[0;92m'
export WHT='\033[0;37m'
export NC='\033[0m' # No Color

# Set personal aliases, overriding those provided by oh-my-zsh libs,
# plugins, and themes. Aliases can be placed here, though oh-my-zsh
# users are encouraged to define aliases within the ZSH_CUSTOM folder.
# For a full list of active aliases, run `alias`.
#
##### System ####
alias ..="cd .."
alias please="sudo"
alias ls="ls -G"
alias t="tree"
alias l="tree -L 1"
alias cls="clear"
alias la="ls -lha"
alias wakeGameBox="wakeonlan -i 10.0.255.255 A8:5E:45:E3:E2:35"
alias wakeMacMini="wakeonlan -i 10.0.255.255 14:C2:13:ED:EF:FE"
alias pubip="dig +short myip.opendns.com @resolver1.opendns.com"
alias listening="lsof -nP +c 15 | grep LISTEN"
alias hack_hosts="sudo vim /etc/hosts"
alias chrome-socks='/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --proxy-server="socks5://127.0.0.1:8080" --host-resolver-rules="MAP * 0.0.0.0 , EXCLUDE localhost"'

#### Go ####
export GOPATH="${HOME}/.go"
export GOBIN=$GOPATH/bin
export GOPROXY=https://proxy.golang.org,direct
export PATH="${GOPATH}/bin:${GOROOT}/bin:$PATH"

#### Git ####
alias g="git"
alias gp="git push"
alias gs="git status"
alias gb="git branch"
alias gc="git commit"
alias gpll="git pull"
alias gco="git checkout"
alias gpm="git add .;git commit;git push"
alias gpn="git add .;git commit;git push --no-verify"
alias gl="git log"
function gsquash() {
  git reset $(git merge-base ${1} HEAD)
  git add -A
  git commit -m ${2}
}
function gprune() {
  git fetch origin
  git fetch --prune origin
  git branch --merged | egrep -v "(^\*|master|main)" | xargs git branch -d
}
function gpa() {
  git add --all
  git commit -am ${1}
  git push
}

#### Pulumi ####
alias p="pulumi"
alias pup="pulumi up"

#### Oh My Zsh ####
export ZSH="$HOME/.oh-my-zsh"

plugins=(git)

# History Settings
export HISTSIZE=10000
export SAVEHIST=10000
export HISTFILE=$HOME/.zsh_history

# ZSH Globals
export UPDATE_ZSH_DAYS=7 # Update every week

# Zsh Configuration
export COMPLETION_WAITING_DOTS="true" # Waiting dots
zstyle ':completion:*' completer _complete _ignored
zstyle :compinstall filename '~/.zshrc'

# Initialize Zsh completion system
autoload -Uz compinit
compinit

# Other Settings
setopt autocd
bindkey -e

#### Python ####
export PATH="$HOME/.pyenv/bin:$PATH"
if command -v pyenv &>/dev/null; then
  eval "$(pyenv init --path)"
  eval "$(pyenv init -)"
fi

function py-venv() {
  emulate -L zsh
  set -e # Exit on any error

  PYTHON_VERSION_FILE="python_version.txt"
  REQUIREMENTS_FILE="requirements.txt"
  REQUIREMENTS_ALT=".venv/requirements.txt"
  REQUIREMENTS_ARG="${1:-}"
  VENV_DIR=".venv"

  # Ensure pyenv is installed
  if ! command -v pyenv &>/dev/null; then
    echo "Warning: pyenv not found. Using system Python."
    USE_PYENV=false
  else
    USE_PYENV=true
  fi

  # Determine the correct Python version
  if [ -f "$PYTHON_VERSION_FILE" ]; then
    PYTHON_VERSION=$(cat "$PYTHON_VERSION_FILE")
    if $USE_PYENV; then
      if ! pyenv versions --bare | grep -qx "$PYTHON_VERSION"; then
        echo "Installing Python $PYTHON_VERSION via pyenv..."
        pyenv install "$PYTHON_VERSION"
      fi
      pyenv local "$PYTHON_VERSION"
    fi
    PYTHON_EXECUTABLE="python3"
  else
    echo "Warning: $PYTHON_VERSION_FILE not found. Using system Python."
    PYTHON_EXECUTABLE="python3"
  fi

  # Create virtual environment if missing
  if [ ! -d "$VENV_DIR" ]; then
    echo "Creating virtual environment in $VENV_DIR..."
    $PYTHON_EXECUTABLE -m venv "$VENV_DIR"
  fi

  # Activate virtual environment
  echo "Activating virtual environment..."
  source "$VENV_DIR/bin/activate"

  # Ensure pip is up-to-date
  echo "Upgrading pip..."
  python -m pip install --upgrade pip

  # Install or update dependencies if requirements.txt exists
  if [ -n "$REQUIREMENTS_ARG" ] && [ -f "$REQUIREMENTS_ARG" ]; then
    REQ_PATH="$REQUIREMENTS_ARG"
  elif [ -f "$REQUIREMENTS_FILE" ]; then
    REQ_PATH="$REQUIREMENTS_FILE"
  elif [ -f "$REQUIREMENTS_ALT" ]; then
    REQ_PATH="$REQUIREMENTS_ALT"
  else
    REQ_PATH=""
  fi

  if [ -n "$REQ_PATH" ]; then
    echo "Installing/updating dependencies from $REQ_PATH..."
    python -m pip install --upgrade -r "$REQ_PATH"
  else
    echo "Warning: requirements file not found (checked $REQUIREMENTS_ARG, $REQUIREMENTS_FILE, and $REQUIREMENTS_ALT). Skipping package installation."
  fi

  echo "âœ… Virtual environment setup complete. You are now inside the virtual environment."
  echo "   To deactivate, type: deactivate"
  return 0

}

# Helm
alias h="helm"

#### K8S ####
if command -v kubectl &>/dev/null; then
  K8S_COMPLETER=$(which kubectl)
  if [ -n "$K8S_COMPLETER" ]; then
    source <(kubectl completion zsh)
  fi
fi

alias k9="k9s"
alias k="kubectl"
alias kd="kubectl describe"
alias kdel="kubectl delete"
alias kex="kubectl exec -it"
alias kg="kubectl get"
alias kga="kubectl get all"
alias kgp="kubectl get po"
alias kl="kubectl logs"
alias kns="kubens"
alias kctx="kubectx"

alias alpine-docker="docker run -it --rm --name alpine-box ghcr.io/vekjja/alpine-box:main"

# Run an ephemeral alpine toolbox pod. Supports either:
# - alpine-k8s sh -c 'echo hi'
# - alpine-k8s 'echo hi'          (runs via sh -lc inside the pod)
function alpine-k8s() {
  if [[ $# -eq 0 ]]; then
    kubectl run alpine-box \
      --image=ghcr.io/vekjja/alpine-box:main \
      --restart=Never \
      --image-pull-policy=Always \
      -it --rm \
      --command -- zsh
    return $?
  fi

  if [[ $# -eq 1 ]]; then
    kubectl run alpine-box \
      --image=ghcr.io/vekjja/alpine-box:main \
      --restart=Never \
      --image-pull-policy=Always \
      -it --rm \
      --command -- sh -c "$1"
    return $?
  fi

  kubectl run alpine-box \
    --image=ghcr.io/vekjja/alpine-box:main \
    --restart=Never \
    --image-pull-policy=Always \
    -it --rm \
    --command -- "$@"
}

#### Docker ###
export DOCKER_BUILDKIT=1
alias d="docker"
alias dc="docker-compose"

#### Encryption ####
function enc() {
  openssl des -in ${1} -out ${1}.enc
}

function dec() {
  openssl des -d -in ${1} -out ${2:-decrypted.txt}
}

function decode() {
  echo
  echo ${1-TXVzdCBQcm92aWRlIEJhc2U2NCBFbmNvZGVkIFN0cmluZwo} | base64 --decode
}

### HTTP ###
http-server() {
  local port=9999 # default port
  local dir="./"  # default directory

  while [[ "$#" -gt 0 ]]; do
    case $1 in
    -p | --port)
      port="$2"
      shift
      ;;
    -d | --dir)
      dir="$2"
      shift
      ;;
    *)
      echo "Unknown parameter passed: $1"
      return 1
      ;;
    esac
    shift
  done

  python3 -m http.server ${port} --directory ${dir}
}

#### SSH ####
function rssh(){
ssh -t $1 "sudo su"
}

function ssh-wait() {
  # Vars
  HOST=$1
  index=1
  sleepSeconds=10
  maxConnectionAttempts=30

  # Wait for the box to become available via ssh
  echo "\nAttempting to SSH to $HOST"

  while (($index <= $maxConnectionAttempts)); do
    printf "\nAttempt ${index} of ${maxConnectionAttempts}\n "
    ssh -T -o ConnectTimeout=2 -o StrictHostKeyChecking=no $HOST date
    case $? in
    0)
      echo " ðŸ‘Œ SSH Success"
      ssh $HOST
      break
      ;;
    *) echo "waiting ${sleepSeconds} seconds...ðŸ’¤" ;;
    esac
    sleep $sleepSeconds
    ((index += 1))
  done

  if [ $index -ge $maxConnectionAttempts ]; then
    echo "â›”ï¸  Error: Max Connection Attempts, $HOST is unreachable "
  fi
}

function ssh-init() {

  HOST=${1}

  echo "${PURP}Initializing Host: ${NC}${HOST}"
  ssh -T ${HOST} <<ENDSSH >/dev/null
sudo apt-get update
sudo apt-get install -y \
  curl \
  ncdu \
  jq \
  gdu \
  zsh \
  vim \
  autojump
ENDSSH

  echo "${PURP}Copy Files:${BLU}"
  scp ~/git/provisions/assets/dotfiles/.zshrc-min ${HOST}:~/.zshrc
  scp ~/git/provisions/assets/dotfiles/.vimrc ${HOST}:~/.

  echo "${PURP}Copying to /root/ using sudo:${BLU}"
  scp ~/git/provisions/assets/dotfiles/.zshrc-min ${HOST}:/tmp/.zshrc-min
  scp ~/git/provisions/assets/dotfiles/.vimrc ${HOST}:/tmp/.vimrc
  ssh ${HOST} "sudo mv /tmp/.zshrc-min /root/.zshrc && sudo mv /tmp/.vimrc /root/.vimrc && sudo chown root:root /root/.zshrc /root/.vimrc"

  echo "${PURP}Entering Host: ${NC}${HOST}"
  ssh ${HOST}
}

function ssh-pf() {
  if [ $# -lt 2 ] || [ $# -gt 3 ]; then
    echo "Usage: ssh-pf [local_port] [host] [host_port (optional, defaults to local_port)]"
    return 1
  fi
  local local_port=$1
  local host=$2
  if [ $# -eq 3 ]; then
    local host_port=$3
  else
    local host_port=$1
  fi
  echo "Forwarding localhost:${local_port} to ${host}:${host_port} via SSH..."
  ssh -N -L ${local_port}:localhost:${host_port} ${host}
}

#### Autojump ####
if command -v autojump &>/dev/null; then
  # Mac with Homebrew
  if command -v brew &>/dev/null && [ -f $(brew --prefix)/etc/profile.d/autojump.sh ]; then
    . $(brew --prefix)/etc/profile.d/autojump.sh
  # Mac with Apple internal Homebrew
  elif [ -f /opt/brew/etc/profile.d/autojump.sh ]; then
    . /opt/brew/etc/profile.d/autojump.sh
  # Ubuntu/Debian package (covers Ubuntu, Pi OS, Kali)
  elif [ -f /usr/share/autojump/autojump.zsh ]; then
    . /usr/share/autojump/autojump.zsh
  # Mac with MacPorts
  elif [ -f /opt/local/etc/profile.d/autojump.zsh ]; then
    . /opt/local/etc/profile.d/autojump.zsh
  # Manual user-local installation
  elif [ -f $HOME/.autojump/etc/profile.d/autojump.zsh ]; then
    . $HOME/.autojump/etc/profile.d/autojump.zsh
  # System-wide manual installation
  elif [ -f /etc/profile.d/autojump.zsh ]; then
    . /etc/profile.d/autojump.zsh
  fi
fi

# Oh My Zsh
if [ -f "$ZSH/oh-my-zsh.sh" ]; then
  source $ZSH/oh-my-zsh.sh
fi

#### Oh My Posh ####
if command -v oh-my-posh &>/dev/null; then
  eval "$(oh-my-posh init zsh --config ~/.kev.omp.json)"
fi
